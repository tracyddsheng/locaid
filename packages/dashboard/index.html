<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>ArcGIS Live Dashboard</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
        #container {
            display: flex;
            height: 100%;
        }
        #sidebar {
            width: 300px;
            padding: 15px;
            box-sizing: border-box;
            background: #f8f8f8;
            overflow-y: auto;
        }
        #viewDiv {
            flex-grow: 1;
        }
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 2;
        }
    </style>
    <script src="https://js.arcgis.com/4.29/"></script>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>Live Dashboard</h1>
            <h2>How it Works</h2>
            <p>This dashboard connects to a relay server to show real-time location data sent from a mobile web client.</p>
            <p>The mobile client uses the browser's Geolocation API to get its coordinates and sends them via an HTTP POST request to a Node.js server.</p>
            <p>The Node.js server immediately relays that location data to this page using a WebSocket connection.</p>
            <p>This page listens for those WebSocket messages and draws a temporary graphic on the map for each unique device. <strong>Note: These points are not saved and will disappear on refresh.</strong></p>
            <h2>Connection Status</h2>
            <div id="connection-status">Connecting to relay server...</div>
            <h2>Layers</h2>
            <div id="layerlist-container"></div>
            <h2>Actions</h2>
            <button id="notifyBtn" style="width: 100%; padding: 10px; font-size: 1em;">Notify Vulnerable Addresses</button>
        </div>
        <div id="viewDiv"></div>
    </div>
    <div id="status"></div>

    <script>
        // --- CONFIGURATION ---
        // Dynamically set the IP for the WebSocket connection
        const WEBSOCKET_IP = window.location.hostname;
        const WEBSOCKET_PORT = 3000;
        // Connect over a SECURE WebSocket connection (wss)
        const WEBSOCKET_URL = `wss://${WEBSOCKET_IP}:${WEBSOCKET_PORT}`;

        // --- DOM ELEMENTS ---
        const statusDiv = document.getElementById('status');
        const connectionStatusDiv = document.getElementById('connection-status');

        require([
            "esri/WebMap",
            "esri/views/MapView",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/geometry/Point", // <-- Import the Point class
            "esri/geometry/geometryEngine",
            "esri/widgets/LayerList"
        ], function(WebMap, MapView, GraphicsLayer, Graphic, Point, geometryEngine, LayerList) {

            // Use a plain JavaScript Object as a dictionary to track graphics by deviceId.
            // Each entry will now hold both the point and the accuracy circle.
            const liveGraphics = {};
            const addressGraphics = {};
            let fireHazardLayer = null;

            const map = new WebMap({
                portalItem: {
                    id: "0d8708f95c71433daa14f4ad6965ff2d"
                }
            });

            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-118.2437, 34.0522], // Los Angeles
                zoom: 10
            });

            // Create a graphics layer to hold the live points
            const graphicsLayer = new GraphicsLayer();
            graphicsLayer.listMode = "hide"; // Don't show in layer list
            map.add(graphicsLayer);

            const layerList = new LayerList({
                view: view,
                container: "layerlist-container"
            });

            // Wait for the map and its layers to finish loading
            map.when(() => {
                fireHazardLayer = map.allLayers.find(layer => {
                    return layer.title === "High Fire Hazard Severity Zones";
                });

                if (fireHazardLayer) {
                    console.log("Successfully found the High Fire Hazard Severity Zones layer.");
                    // Ensure the layer is visible by default for the query to work reliably
                    fireHazardLayer.visible = true;
                } else {
                    console.error("Could not find the 'High Fire Hazard Severity Zones' layer. Please check the WebMap configuration.");
                    updateStatus("Fire Hazard Layer not found!", true);
                }
            });


            // --- WEBSOCKET CONNECTION ---
            setupWebSocket();

            function setupWebSocket() {
                const socket = new WebSocket(WEBSOCKET_URL);

                socket.onopen = () => updateStatus('Connected to relay server.', false, true);

                socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    // Check if it's an array (initial address load) or single object (live update)
                    if (Array.isArray(data)) {
                        console.log(`Received initial batch of ${data.length} static addresses.`);
                        data.forEach(address => updateMapGraphic(address));
                    } else {
                        updateStatus(`Received location from ${data.deviceId}`, false);
                        updateMapGraphic(data);
                    }
                };

                socket.onclose = () => {
                    updateStatus('Disconnected. Retrying...', true);
                    console.error("WebSocket closed. Is the server running? Retrying...");
                    setTimeout(setupWebSocket, 3000);
                };

                socket.onerror = (error) => {
                    updateStatus('WebSocket error.', true);
                    console.error('WebSocket Error:', error);
                    socket.close();
                };
            }

            function updateMapGraphic(locationData) {
                const { latitude, longitude, deviceId, accuracy, type = 'user' } = locationData;
                
                if (type === 'address') {
                    // This is where you would load a FeatureLayer in a real app.
                    // For now, we create graphics from the simulated data.
                    if (!addressGraphics[deviceId]) {
                         const point = new Point({ longitude, latitude });
                         const addressSymbol = {
                            type: "simple-marker",
                            style: "diamond",
                            size: 10,
                            color: [0, 0, 139], // Dark Blue
                            outline: { width: 1, color: "white" }
                         };
                         const addressGraphic = new Graphic({
                             geometry: point,
                             symbol: addressSymbol,
                             attributes: locationData,
                             popupTemplate: {
                                 title: "Vulnerable Address",
                                 content: "Device ID: {deviceId}"
                             }
                         });
                         graphicsLayer.add(addressGraphic);
                         addressGraphics[deviceId] = addressGraphic;
                    }
                    return; // End processing for static addresses
                }

                const point = new Point({
                    longitude: longitude,
                    latitude: latitude
                });

                const accuracyCircle = geometryEngine.geodesicBuffer(point, accuracy, "meters");

                // Define symbols based on the user type
                const pointColor = type === 'responder' ? [0, 122, 194] : [226, 119, 40]; // Blue for responders, Orange for users
                const pointSymbol = {
                    type: "simple-marker",
                    size: 6,
                    color: pointColor,
                    outline: { width: 1, color: "white" }
                };
                const circleSymbol = {
                    type: "simple-fill",
                    color: [...pointColor, 0.2], // Use the same base color but with transparency
                    outline: {
                        color: [255, 255, 255, 0.5],
                        width: 1
                    }
                };
                
                if (liveGraphics[deviceId]) {
                    const graphics = liveGraphics[deviceId];
                    graphics.point.geometry = point;
                    graphics.circle.geometry = accuracyCircle;
                    graphics.point.symbol = pointSymbol; // Update symbol in case type changes
                    graphics.circle.symbol = circleSymbol;
                    graphics.point.attributes.accuracy = accuracy.toFixed(0);
                } else {
                    const circleGraphic = new Graphic({
                        geometry: accuracyCircle,
                        symbol: circleSymbol
                    });

                    const pointGraphic = new Graphic({
                        geometry: point,
                        symbol: pointSymbol,
                        attributes: {
                            deviceId: deviceId,
                            accuracy: accuracy.toFixed(0),
                            type: type
                        },
                        popupTemplate: {
                            title: "{type}: {deviceId}",
                            content: "Reported accuracy: {accuracy} meters."
                        }
                    });

                    graphicsLayer.addMany([circleGraphic, pointGraphic]);
                    
                    // Store references to both graphics.
                    liveGraphics[deviceId] = {
                        point: pointGraphic,
                        circle: circleGraphic
                    };

                    // After adding a new device, adjust the map view to show all devices.
                    if (graphicsLayer.graphics.length > 0) {
                        view.goTo(graphicsLayer.graphics);
                    }
                }
            }

            function updateStatus(message, isError = false, isConnectionStatus = false) {
                const targetDiv = isConnectionStatus ? connectionStatusDiv : statusDiv;
                targetDiv.textContent = message;
                targetDiv.style.color = isError ? '#d9534f' : '#28a745';
                
                if (isConnectionStatus) {
                    targetDiv.style.fontWeight = 'bold';
                }

                if (!isConnectionStatus) {
                    statusDiv.style.display = 'block';
                    setTimeout(() => { statusDiv.style.display = 'none'; }, 4000);
                }
            }

            document.getElementById('notifyBtn').addEventListener('click', () => {
                if (!fireHazardLayer) {
                    updateStatus("Fire Hazard Layer not ready. Cannot perform notification.", true);
                    return;
                }

                // Create a query object from the fire hazard layer
                const query = fireHazardLayer.createQuery();
                query.geometry = {
                    type: "multipoint",
                    points: Object.values(addressGraphics).map(graphic => [graphic.geometry.longitude, graphic.geometry.latitude])
                };
                query.spatialRelationship = "intersects"; // Find polygons that contain our points

                fireHazardLayer.queryObjectIds(query).then(objectIds => {
                    if (!objectIds || objectIds.length === 0) {
                        updateStatus("No addresses are within high fire hazard zones.", false);
                        return;
                    }

                    console.log(`Found ${objectIds.length} addresses in fire zones.`);
                    const notifiedSymbol = {
                        type: "simple-marker",
                        style: "diamond",
                        size: 12,
                        color: [255, 0, 0], // Red
                        outline: { width: 2, color: "yellow" }
                    };
                    
                    // A bit of a trick: we can't directly get back which point belongs to which polygon hit.
                    // So we query the layer for the geometries of the polygons that were hit.
                    fireHazardLayer.queryFeatures({ objectIds, returnGeometry: true }).then(featureSet => {
                         const fireZoneGeometries = featureSet.features.map(f => f.geometry);
                         // Now check each of our address graphics to see if it's inside any of these hot zones.
                         for (const deviceId in addressGraphics) {
                             const addressGraphic = addressGraphics[deviceId];
                             const isVulnerable = geometryEngine.intersects(fireZoneGeometries, addressGraphic.geometry);
                             if (isVulnerable) {
                                 addressGraphic.symbol = notifiedSymbol;
                             }
                         }
                         updateStatus(`${objectIds.length} vulnerable addresses notified!`, false);
                    });
                }).catch(err => {
                    console.error("Error querying fire hazard layer:", err);
                    updateStatus("Error during notification.", true);
                });
            });
        });
    </script>
</body>
</html> 