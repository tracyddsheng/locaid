<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>ArcGIS Live Dashboard</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
        #container {
            display: flex;
            height: 100%;
        }
        #sidebar {
            width: 300px;
            padding: 15px;
            box-sizing: border-box;
            background: #f8f8f8;
            overflow-y: auto;
        }
        #viewDiv {
            flex-grow: 1;
        }
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 2;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            max-height: 80%;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 1.2em;
        }
        .close-button {
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        .modal-body {
            overflow-y: auto;
        }
        .modal-body ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .modal-body li {
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
    </style>
    <script src="https://js.arcgis.com/4.29/"></script>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>Live Dashboard</h1>
            <h2>How it Works</h2>
            <p>This dashboard connects to a relay server to show real-time location data sent from a mobile web client.</p>
            <p>The mobile client uses the browser's Geolocation API to get its coordinates and sends them via an HTTP POST request to a Node.js server.</p>
            <p>The Node.js server immediately relays that location data to this page using a WebSocket connection.</p>
            <p>This page listens for those WebSocket messages and draws a temporary graphic on the map for each unique device. <strong>Note: These points are not saved and will disappear on refresh.</strong></p>
            <h2>Connection Status</h2>
            <div id="connection-status">Connecting to relay server...</div>
            <h2>Layers</h2>
            <div id="layerlist-container"></div>
            <h2>Actions</h2>
            <button id="notifyBtn" style="width: 100%; padding: 10px; font-size: 1em;">Notify Vulnerable Addresses</button>
            <h2>Live Units</h2>
            <div id="live-units-list" style="max-height: 200px; overflow-y: auto;"></div>
        </div>
        <div id="viewDiv"></div>
    </div>
    <div id="status"></div>

    <div id="notification-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Notified Users</h2>
                <span class="close-button">&times;</span>
            </div>
            <div id="notified-users-list" class="modal-body">
                <!-- List will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        // Dynamically set the IP for the WebSocket connection
        const WEBSOCKET_IP = window.location.hostname;
        const WEBSOCKET_PORT = 3000;
        // Connect over a SECURE WebSocket connection (wss)
        const WEBSOCKET_URL = `wss://${WEBSOCKET_IP}:${WEBSOCKET_PORT}`;

        // --- DOM ELEMENTS ---
        const statusDiv = document.getElementById('status');
        const connectionStatusDiv = document.getElementById('connection-status');

        require([
            "esri/config",
            "esri/WebMap",
            "esri/views/MapView",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/geometry/Point", // <-- Import the Point class
            "esri/geometry/geometryEngine",
            "esri/widgets/LayerList"
        ], function(esriConfig, WebMap, MapView, GraphicsLayer, Graphic, Point, geometryEngine, LayerList) {

            // --- PROXY CONFIGURATION ---
            // This is a standard solution for CORS issues where a browser on one domain (localhost)
            // is blocked from accessing services on another domain. The proxy makes the request on our behalf.
            const prefixes = ["services", "services1", "services2", "services3", "services4", "services5", "services6", "services7", "services8", "services9"];
            prefixes.forEach(prefix => {
                esriConfig.request.proxyRules.push({
                    urlPrefix: `https://${prefix}.arcgis.com`,
                    proxyUrl: "https://www.arcgis.com/sharing/proxy"
                });
            });

            // Add a specific rule for the LA County GIS server
            esriConfig.request.proxyRules.push({
                urlPrefix: "https://public.gis.lacounty.gov",
                proxyUrl: "https://www.arcgis.com/sharing/proxy"
            });


            // Use a plain JavaScript Object as a dictionary to track graphics by deviceId.
            // Each entry will now hold both the point and the accuracy circle.
            const liveGraphics = {};
            const addressGraphics = {};
            let fireHazardLayer = null;
            const STALE_DATA_TIMEOUT = 30000; // 30 seconds
            let signUpData = []; // To store the results from the user layer

            const map = new WebMap({
                portalItem: {
                    id: "0d8708f95c71433daa14f4ad6965ff2d"
                }
            });

            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-118.15, 34.16], // Centered on the new operational area
                zoom: 12
            });

            // Create a graphics layer to hold the live points
            const graphicsLayer = new GraphicsLayer();
            graphicsLayer.listMode = "hide"; // Don't show in layer list

            // Define the labeling for the live trackers
            const labelClass = {
                symbol: {
                    type: "text",
                    color: "black",
                    haloSize: 1,
                    haloColor: "white",
                    font: { size: "10pt", family: "sans-serif", weight: "bold" }
                },
                labelPlacement: "above-right",
                labelExpressionInfo: {
                    expression: "$feature.deviceId"
                }
            };
            graphicsLayer.labelingInfo = [labelClass];

            map.add(graphicsLayer);

            const layerList = new LayerList({
                view: view,
                container: "layerlist-container"
            });

            // Wait for the map and its layers to finish loading
            map.when(() => {
                fireHazardLayer = map.allLayers.find(layer => {
                    return layer.title === "Fire Hazard Severity Zones";
                });

                if (fireHazardLayer) {
                    console.log("Successfully found the Fire Hazard Severity Zones layer.");
                    // Ensure the layer is visible by default for the query to work reliably
                    fireHazardLayer.visible = true;
                } else {
                    console.error("Could not find the 'Fire Hazard Severity Zones' layer. Please check the WebMap configuration.");
                    updateStatus("Fire Hazard Layer not found!", true);
                }

                // --- Find and log the LocAid User Sign Up layer ---
                const userSignUpLayer = map.allLayers.find(layer => {
                    return layer.title === "LocAid Users";
                });

                if (userSignUpLayer) {
                    console.log("Found 'LocAid Users' layer. Querying features...");
                    userSignUpLayer.when(() => {
                        // --- LOG 1: Log the layer's fields to verify names ---
                        console.log("Verifying 'LocAid Users' fields:", userSignUpLayer.fields.map(f => f.name));
                        return userSignUpLayer.queryFeatures();
                    })
                    .then(results => {
                        console.log(`Successfully queried ${results.features.length} features from the sign-up layer.`);
                        signUpData = results.features; // Store the features
                        const userAttributes = signUpData.map(feature => feature.attributes);
                        console.log("LocAid User Sign Up Data:", userAttributes);
                    })
                    .catch(err => {
                        console.error("Error querying the LocAid Users layer:", err);
                    });
                } else {
                    console.warn("Could not find the 'LocAid Users' layer in the WebMap.");
                }
            });


            // --- WEBSOCKET CONNECTION ---
            setupWebSocket();

            function setupWebSocket() {
                const socket = new WebSocket(WEBSOCKET_URL);

                socket.onopen = () => updateStatus('Connected to relay server.', false, true);

                socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    // Check if it's an array (initial address load) or single object (live update)
                    if (Array.isArray(data)) {
                        console.log(`Received initial batch of ${data.length} static addresses.`);
                        data.forEach(address => updateMapGraphic(address));
                    } else {
                        updateStatus(`Received location from ${data.deviceId}`, false);
                        updateMapGraphic(data);
                    }
                };

                socket.onclose = () => {
                    updateStatus('Disconnected. Retrying...', true);
                    console.error("WebSocket closed. Is the server running? Retrying...");
                    setTimeout(setupWebSocket, 3000);
                };

                socket.onerror = (error) => {
                    updateStatus('WebSocket error.', true);
                    console.error('WebSocket Error:', error);
                    socket.close();
                };
            }

            function updateLiveUnitsList() {
                const listContainer = document.getElementById('live-units-list');
                listContainer.innerHTML = ''; // Clear the list
                for (const deviceId in liveGraphics) {
                    const listItem = document.createElement('div');
                    listItem.textContent = deviceId;
                    listItem.style.cursor = 'pointer';
                    listItem.style.padding = '5px';
                    listItem.dataset.deviceId = deviceId;
                    listContainer.appendChild(listItem);
                }
            }

            document.getElementById('live-units-list').addEventListener('click', (event) => {
                const deviceId = event.target.dataset.deviceId;
                if (deviceId && liveGraphics[deviceId]) {
                    view.goTo(liveGraphics[deviceId].point.geometry);
                }
            });


            function updateMapGraphic(locationData) {
                const { latitude, longitude, deviceId, accuracy, type = 'user' } = locationData;
                
                if (type === 'address') {
                    // This is where you would load a FeatureLayer in a real app.
                    // For now, we create graphics from the simulated data.
                    if (!addressGraphics[deviceId]) {
                         const point = new Point({ longitude, latitude });
                         const addressSymbol = {
                            type: "simple-marker",
                            style: "diamond",
                            size: 6, // Smaller size for static data
                            color: [0, 0, 139], // Dark Blue
                            outline: { width: 1, color: "white" }
                         };
                         const addressGraphic = new Graphic({
                             geometry: point,
                             symbol: addressSymbol,
                             attributes: locationData,
                             popupTemplate: {
                                 title: "Vulnerable Address",
                                 content: "Device ID: {deviceId}"
                             }
                         });
                         graphicsLayer.add(addressGraphic);
                         addressGraphics[deviceId] = addressGraphic;
                    }
                    return; // End processing for static addresses
                }

                const point = new Point({
                    longitude: longitude,
                    latitude: latitude
                });

                const accuracyCircle = geometryEngine.geodesicBuffer(point, accuracy, "meters");

                // Define symbols based on the user type
                const pointColor = type === 'responder' ? [0, 122, 194] : [226, 119, 40]; // Blue for responders, Orange for users
                const pointSymbol = {
                    type: "simple-marker",
                    size: 12, // Increased size for better visibility
                    color: pointColor,
                    outline: { width: 1, color: "white" }
                };
                const circleSymbol = {
                    type: "simple-fill",
                    color: [...pointColor, 0.2], // Use the same base color but with transparency
                    outline: {
                        color: [255, 255, 255, 0.5],
                        width: 1
                    }
                };
                
                if (liveGraphics[deviceId]) {
                    const graphics = liveGraphics[deviceId];
                    graphics.point.geometry = point;
                    graphics.circle.geometry = accuracyCircle;
                    graphics.point.symbol = pointSymbol; // Update symbol in case type changes
                    graphics.circle.symbol = circleSymbol;
                    graphics.point.attributes.accuracy = accuracy ? accuracy.toFixed(0) : 0;
                    graphics.lastUpdate = Date.now(); // Update timestamp
                } else {
                    const circleGraphic = new Graphic({
                        geometry: accuracyCircle,
                        symbol: circleSymbol
                    });

                    const pointGraphic = new Graphic({
                        geometry: point,
                        symbol: pointSymbol,
                        attributes: {
                            deviceId: deviceId,
                            accuracy: accuracy ? accuracy.toFixed(0) : 0,
                            type: type
                        },
                        popupTemplate: {
                            title: "{type}: {deviceId}",
                            content: "Reported accuracy: {accuracy} meters."
                        }
                    });

                    graphicsLayer.addMany([circleGraphic, pointGraphic]);
                    
                    liveGraphics[deviceId] = {
                        point: pointGraphic,
                        circle: circleGraphic,
                        lastUpdate: Date.now() // Set initial timestamp
                    };
                    updateLiveUnitsList(); // Update the list when a new unit appears

                    if (graphicsLayer.graphics.length > 0) {
                        view.goTo(graphicsLayer.graphics);
                    }
                }
            }

            function cleanupStaleData() {
                const now = Date.now();
                for (const deviceId in liveGraphics) {
                    if (now - liveGraphics[deviceId].lastUpdate > STALE_DATA_TIMEOUT) {
                        console.log(`Removing stale unit: ${deviceId}`);
                        graphicsLayer.remove(liveGraphics[deviceId].point);
                        graphicsLayer.remove(liveGraphics[deviceId].circle);
                        delete liveGraphics[deviceId];
                        updateLiveUnitsList(); // Update the list
                    }
                }
            }
            setInterval(cleanupStaleData, 10000); // Check for stale data every 10 seconds

            function updateStatus(message, isError = false, isConnectionStatus = false) {
                const targetDiv = isConnectionStatus ? connectionStatusDiv : statusDiv;
                targetDiv.textContent = message;
                targetDiv.style.color = isError ? '#d9534f' : '#28a745';
                
                if (isConnectionStatus) {
                    targetDiv.style.fontWeight = 'bold';
                }

                if (!isConnectionStatus) {
                    statusDiv.style.display = 'block';
                    setTimeout(() => { statusDiv.style.display = 'none'; }, 4000);
                }
            }

            function showNotificationModal(users) {
                const list = document.getElementById('notified-users-list');
                list.innerHTML = '<ul>' + users.map(user => {
                    const name = `${user.attributes.first_name || ''} ${user.attributes.last_name || ''}`.trim() || 'N/A';
                    const phone = user.attributes.phone_number || 'N/A';
                    return `<li><strong>${name}</strong> - ${phone}</li>`;
                }).join('') + '</ul>';

                document.getElementById('notification-modal').style.display = 'flex';
            }

            function hideNotificationModal() {
                document.getElementById('notification-modal').style.display = 'none';
            }

            // Add event listener for the modal close button
            document.querySelector('.close-button').addEventListener('click', hideNotificationModal);
            // Also close when clicking the overlay
            document.getElementById('notification-modal').addEventListener('click', (event) => {
                if (event.target.id === 'notification-modal') {
                    hideNotificationModal();
                }
            });


            document.getElementById('notifyBtn').addEventListener('click', () => {
                if (!fireHazardLayer) {
                    updateStatus("Fire Hazard Layer not ready. Cannot perform notification.", true);
                    return;
                }
                if (signUpData.length === 0) {
                    updateStatus("User sign-up data not loaded yet.", true);
                    return;
                }
                console.log("Starting notification process for signed-up users...");

                const userGeometries = signUpData.map(f => f.geometry).filter(g => g != null);
                if (userGeometries.length === 0) {
                    updateStatus("No users with valid locations found.", false);
                    return;
                }

                const query = fireHazardLayer.createQuery();
                query.geometry = { type: "multipoint", points: userGeometries.map(g => [g.longitude, g.latitude]) };
                query.spatialRelationship = "intersects";
                // We don't need any fields back from the fire layer, just its geometry.
                // query.outFields = ["first_name", "last_name", "phone_number", "objectid"]; 
                query.returnGeometry = true; 

                // --- LOG 2: Log the exact query object being sent ---
                console.log("Executing spatial query with parameters:", JSON.stringify(query.toJSON(), null, 2));

                fireHazardLayer.queryFeatures(query).then(featureSet => {
                    const vulnerableUsers = featureSet.features;
                    if (!vulnerableUsers || vulnerableUsers.length === 0) {
                        updateStatus("No signed-up users are within high fire hazard zones.", false);
                        return;
                    }

                    const notifiedUsers = signUpData.filter(userFeature => {
                        const userGeom = userFeature.geometry;
                        if (!userGeom) return false;
                        // Check if the user's location intersects with any of the returned fire zones
                        return vulnerableUsers.some(fireFeature => geometryEngine.intersects(fireFeature.geometry, userGeom));
                    });
                    
                    if (notifiedUsers.length > 0) {
                        showNotificationModal(notifiedUsers);
                        updateStatus(`${notifiedUsers.length} vulnerable users notified!`, false);
                    } else {
                        updateStatus("No signed-up users are within high fire hazard zones.", false);
                    }
                
                }).catch(err => {
                    console.error("Error querying fire hazard layer for users:", err);
                    updateStatus("Error during user notification.", true);
                });
            });
        });
    </script>
</body>
</html> 