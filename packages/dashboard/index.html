<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>ArcGIS Live Dashboard</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />
    <style>
        html, body, #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
        #container {
            display: flex;
            height: 100%;
        }
        #sidebar {
            width: 300px;
            padding: 15px;
            box-sizing: border-box;
            background: #f8f8f8;
            overflow-y: auto;
        }
        #viewDiv {
            flex-grow: 1;
        }
        #status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 2;
        }
    </style>
    <script src="https://js.arcgis.com/4.29/"></script>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>Live Dashboard</h1>
            <h2>How it Works</h2>
            <p>This dashboard connects to a relay server to show real-time location data sent from a mobile web client.</p>
            <p>The mobile client uses the browser's Geolocation API to get its coordinates and sends them via an HTTP POST request to a Node.js server.</p>
            <p>The Node.js server immediately relays that location data to this page using a WebSocket connection.</p>
            <p>This page listens for those WebSocket messages and draws a temporary graphic on the map for each unique device. <strong>Note: These points are not saved and will disappear on refresh.</strong></p>
            <h2>Connection Status</h2>
            <div id="connection-status">Connecting to relay server...</div>
            <h2>Layers</h2>
            <div id="layerlist-container"></div>
            <h2>Actions</h2>
            <button id="notifyBtn" style="width: 100%; padding: 10px; font-size: 1em;">Notify Vulnerable Addresses</button>
            <h2>Live Units</h2>
            <div id="live-units-list" style="max-height: 200px; overflow-y: auto;"></div>
        </div>
        <div id="viewDiv"></div>
    </div>
    <div id="status"></div>

    <script>
        // --- CONFIGURATION ---
        // Dynamically set the IP for the WebSocket connection
        const WEBSOCKET_IP = window.location.hostname;
        const WEBSOCKET_PORT = 3000;
        // Connect over a SECURE WebSocket connection (wss)
        const WEBSOCKET_URL = `wss://${WEBSOCKET_IP}:${WEBSOCKET_PORT}`;

        // --- DOM ELEMENTS ---
        const statusDiv = document.getElementById('status');
        const connectionStatusDiv = document.getElementById('connection-status');

        require([
            "esri/config",
            "esri/WebMap",
            "esri/views/MapView",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/geometry/Point", // <-- Import the Point class
            "esri/geometry/geometryEngine",
            "esri/widgets/LayerList"
        ], function(esriConfig, WebMap, MapView, GraphicsLayer, Graphic, Point, geometryEngine, LayerList) {

            // --- PROXY CONFIGURATION ---
            // This is a standard solution for CORS issues where a browser on one domain (localhost)
            // is blocked from accessing services on another domain. The proxy makes the request on our behalf.
            const prefixes = ["services", "services1", "services2", "services3", "services4", "services5", "services6", "services7", "services8", "services9"];
            prefixes.forEach(prefix => {
                esriConfig.request.proxyRules.push({
                    urlPrefix: `https://${prefix}.arcgis.com`,
                    proxyUrl: "https://www.arcgis.com/sharing/proxy"
                });
            });


            // Use a plain JavaScript Object as a dictionary to track graphics by deviceId.
            // Each entry will now hold both the point and the accuracy circle.
            const liveGraphics = {};
            const addressGraphics = {};
            let fireHazardLayer = null;
            const STALE_DATA_TIMEOUT = 30000; // 30 seconds

            const map = new WebMap({
                portalItem: {
                    id: "0d8708f95c71433daa14f4ad6965ff2d"
                }
            });

            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-118.15, 34.16], // Centered on the new operational area
                zoom: 12
            });

            // Create a graphics layer to hold the live points
            const graphicsLayer = new GraphicsLayer();
            graphicsLayer.listMode = "hide"; // Don't show in layer list

            // Define the labeling for the live trackers
            const labelClass = {
                symbol: {
                    type: "text",
                    color: "black",
                    haloSize: 1,
                    haloColor: "white",
                    font: { size: "10pt", family: "sans-serif", weight: "bold" }
                },
                labelPlacement: "above-right",
                labelExpressionInfo: {
                    expression: "$feature.deviceId"
                }
            };
            graphicsLayer.labelingInfo = [labelClass];

            map.add(graphicsLayer);

            const layerList = new LayerList({
                view: view,
                container: "layerlist-container"
            });

            // Wait for the map and its layers to finish loading
            map.when(() => {
                fireHazardLayer = map.allLayers.find(layer => {
                    return layer.title === "High Fire Hazard Severity Zones";
                });

                if (fireHazardLayer) {
                    console.log("Successfully found the High Fire Hazard Severity Zones layer.");
                    // Ensure the layer is visible by default for the query to work reliably
                    fireHazardLayer.visible = true;
                } else {
                    console.error("Could not find the 'High Fire Hazard Severity Zones' layer. Please check the WebMap configuration.");
                    updateStatus("Fire Hazard Layer not found!", true);
                }
            });


            // --- WEBSOCKET CONNECTION ---
            setupWebSocket();

            function setupWebSocket() {
                const socket = new WebSocket(WEBSOCKET_URL);

                socket.onopen = () => updateStatus('Connected to relay server.', false, true);

                socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    // Check if it's an array (initial address load) or single object (live update)
                    if (Array.isArray(data)) {
                        console.log(`Received initial batch of ${data.length} static addresses.`);
                        data.forEach(address => updateMapGraphic(address));
                    } else {
                        updateStatus(`Received location from ${data.deviceId}`, false);
                        updateMapGraphic(data);
                    }
                };

                socket.onclose = () => {
                    updateStatus('Disconnected. Retrying...', true);
                    console.error("WebSocket closed. Is the server running? Retrying...");
                    setTimeout(setupWebSocket, 3000);
                };

                socket.onerror = (error) => {
                    updateStatus('WebSocket error.', true);
                    console.error('WebSocket Error:', error);
                    socket.close();
                };
            }

            function updateLiveUnitsList() {
                const listContainer = document.getElementById('live-units-list');
                listContainer.innerHTML = ''; // Clear the list
                for (const deviceId in liveGraphics) {
                    const listItem = document.createElement('div');
                    listItem.textContent = deviceId;
                    listItem.style.cursor = 'pointer';
                    listItem.style.padding = '5px';
                    listItem.dataset.deviceId = deviceId;
                    listContainer.appendChild(listItem);
                }
            }

            document.getElementById('live-units-list').addEventListener('click', (event) => {
                const deviceId = event.target.dataset.deviceId;
                if (deviceId && liveGraphics[deviceId]) {
                    view.goTo(liveGraphics[deviceId].point.geometry);
                }
            });


            function updateMapGraphic(locationData) {
                const { latitude, longitude, deviceId, accuracy, type = 'user' } = locationData;
                
                if (type === 'address') {
                    // This is where you would load a FeatureLayer in a real app.
                    // For now, we create graphics from the simulated data.
                    if (!addressGraphics[deviceId]) {
                         const point = new Point({ longitude, latitude });
                         const addressSymbol = {
                            type: "simple-marker",
                            style: "diamond",
                            size: 6, // Smaller size for static data
                            color: [0, 0, 139], // Dark Blue
                            outline: { width: 1, color: "white" }
                         };
                         const addressGraphic = new Graphic({
                             geometry: point,
                             symbol: addressSymbol,
                             attributes: locationData,
                             popupTemplate: {
                                 title: "Vulnerable Address",
                                 content: "Device ID: {deviceId}"
                             }
                         });
                         graphicsLayer.add(addressGraphic);
                         addressGraphics[deviceId] = addressGraphic;
                    }
                    return; // End processing for static addresses
                }

                const point = new Point({
                    longitude: longitude,
                    latitude: latitude
                });

                const accuracyCircle = geometryEngine.geodesicBuffer(point, accuracy, "meters");

                // Define symbols based on the user type
                const pointColor = type === 'responder' ? [0, 122, 194] : [226, 119, 40]; // Blue for responders, Orange for users
                const pointSymbol = {
                    type: "simple-marker",
                    size: 12, // Increased size for better visibility
                    color: pointColor,
                    outline: { width: 1, color: "white" }
                };
                const circleSymbol = {
                    type: "simple-fill",
                    color: [...pointColor, 0.2], // Use the same base color but with transparency
                    outline: {
                        color: [255, 255, 255, 0.5],
                        width: 1
                    }
                };
                
                if (liveGraphics[deviceId]) {
                    const graphics = liveGraphics[deviceId];
                    graphics.point.geometry = point;
                    graphics.circle.geometry = accuracyCircle;
                    graphics.point.symbol = pointSymbol; // Update symbol in case type changes
                    graphics.circle.symbol = circleSymbol;
                    graphics.point.attributes.accuracy = accuracy ? accuracy.toFixed(0) : 0;
                    graphics.lastUpdate = Date.now(); // Update timestamp
                } else {
                    const circleGraphic = new Graphic({
                        geometry: accuracyCircle,
                        symbol: circleSymbol
                    });

                    const pointGraphic = new Graphic({
                        geometry: point,
                        symbol: pointSymbol,
                        attributes: {
                            deviceId: deviceId,
                            accuracy: accuracy ? accuracy.toFixed(0) : 0,
                            type: type
                        },
                        popupTemplate: {
                            title: "{type}: {deviceId}",
                            content: "Reported accuracy: {accuracy} meters."
                        }
                    });

                    graphicsLayer.addMany([circleGraphic, pointGraphic]);
                    
                    liveGraphics[deviceId] = {
                        point: pointGraphic,
                        circle: circleGraphic,
                        lastUpdate: Date.now() // Set initial timestamp
                    };
                    updateLiveUnitsList(); // Update the list when a new unit appears

                    if (graphicsLayer.graphics.length > 0) {
                        view.goTo(graphicsLayer.graphics);
                    }
                }
            }

            function cleanupStaleData() {
                const now = Date.now();
                for (const deviceId in liveGraphics) {
                    if (now - liveGraphics[deviceId].lastUpdate > STALE_DATA_TIMEOUT) {
                        console.log(`Removing stale unit: ${deviceId}`);
                        graphicsLayer.remove(liveGraphics[deviceId].point);
                        graphicsLayer.remove(liveGraphics[deviceId].circle);
                        delete liveGraphics[deviceId];
                        updateLiveUnitsList(); // Update the list
                    }
                }
            }
            setInterval(cleanupStaleData, 10000); // Check for stale data every 10 seconds

            function updateStatus(message, isError = false, isConnectionStatus = false) {
                const targetDiv = isConnectionStatus ? connectionStatusDiv : statusDiv;
                targetDiv.textContent = message;
                targetDiv.style.color = isError ? '#d9534f' : '#28a745';
                
                if (isConnectionStatus) {
                    targetDiv.style.fontWeight = 'bold';
                }

                if (!isConnectionStatus) {
                    statusDiv.style.display = 'block';
                    setTimeout(() => { statusDiv.style.display = 'none'; }, 4000);
                }
            }

            document.getElementById('notifyBtn').addEventListener('click', () => {
                if (!fireHazardLayer) {
                    updateStatus("Fire Hazard Layer not ready. Cannot perform notification.", true);
                    return;
                }
                console.log("Starting notification process...");

                const allAddressPoints = Object.values(addressGraphics).map(graphic => graphic.geometry);
                if (allAddressPoints.length === 0) {
                    updateStatus("No addresses loaded yet.", false);
                    return;
                }

                const query = fireHazardLayer.createQuery();
                query.geometry = {
                    type: "multipoint",
                    points: allAddressPoints.map(p => [p.longitude, p.latitude])
                };
                query.spatialRelationship = "intersects";
                query.returnGeometry = true; // We need the geometries of the fire zones

                console.log(`Querying fire hazard layer with ${allAddressPoints.length} address points.`);

                fireHazardLayer.queryFeatures(query).then(featureSet => {
                    // Filter out any features that might have come back with null geometry
                    const fireZoneGeometries = featureSet.features
                        .map(f => f.geometry)
                        .filter(geom => geom != null);

                    if (fireZoneGeometries.length === 0) {
                        updateStatus("No addresses are within high fire hazard zones.", false);
                        console.log("Query returned 0 intersecting fire hazard zones or zones had null geometry.");
                        return;
                    }

                    console.log(`Found ${fireZoneGeometries.length} valid fire zones that contain addresses. Now checking which addresses are vulnerable.`);
                    
                    const notifiedSymbol = {
                        type: "simple-marker", style: "diamond", size: 12,
                        color: [255, 0, 0], // Red
                        outline: { width: 2, color: "yellow" }
                    };
                    
                    let notifiedCount = 0;
                    for (const deviceId in addressGraphics) {
                         const addressGraphic = addressGraphics[deviceId];
                         if (addressGraphic && addressGraphic.geometry) {
                             // Loop through each fire zone to check for intersection individually
                             for (const zone of fireZoneGeometries) {
                                if (geometryEngine.intersects(zone, addressGraphic.geometry)) {
                                    addressGraphic.symbol = notifiedSymbol;
                                    notifiedCount++;
                                    break; // Move to the next address once found in any zone
                                }
                             }
                         }
                    }

                    if (notifiedCount > 0) {
                        updateStatus(`${notifiedCount} vulnerable addresses notified!`, false);
                        console.log(`Highlighted ${notifiedCount} addresses.`);
                    } else {
                        updateStatus("Found fire zones, but could not match to specific addresses.", true);
                        console.warn("Intersection logic did not find matches after an initial hit. This might indicate a data projection or precision issue.");
                    }

                }).catch(err => {
                    console.error("Error querying fire hazard layer:", err);
                    updateStatus("Error during notification query.", true);
                });
            });
        });
    </script>
</body>
</html> 