<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="styles/Button.css">
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />
    <title>Location Tracker</title>
    <style>
        body {
            font-family: 'Barlow';
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            text-align: center;
        }

        #status {
            margin: 20px;
            padding: 10px 20px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 280px;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            font-size: 1.2em;
            padding: 15px 30px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            color: white;
            transition: background-color 0.2s;
        }

        .hidden {
            display: none;
        }

        #arrow-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        #arrow {
            width: 80px;
            height: 80px;
            transition: transform 0.2s ease-out;
            filter: drop-shadow(0 0 10px rgba(153, 9, 9, 0.5));
        }

        .button-group {
            position: absolute;
            top: 8px;
            right: 8px;
        }
    </style>

    <link rel="stylesheet" href="styles/SearchBar.css">

    <title>Location Tracker</title>


    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            width: 95%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .logo {
            height: 50px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            height: 100%;
        }

        .welcome-text {
            margin-bottom: 2rem;
        }

        .button-container {
            display: flex;
            gap: 1rem;
            flex-direction: column;
            width: 100%;
            max-width: 300px;
        }

        .content-contatiner {
            width: 100%;
            height: 100%;

            position: relative;
        }

        .map-container {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            flex: 1;
        }

        #viewDiv {
            width: 100%;
            height: 100%;
        }

        #filter-layers-btn {
            background-color: #42454A;
        }

        #route-to-button {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: solid 1px black;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            z-index: 1000;
        }

        #list-destination {
            max-height: 200px;
            background-color: white;
            padding: 12px 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: none;
            overflow-y: auto;
            z-index: 1000;
        }

        .destination-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .destination-item:hover {
            background-color: #f0f0f0;
        }

        .destination-item:last-child {
            border-bottom: none;
        }
    </style>
</head>

<body>
    <header class="header" style="background-color: white;">
        <img src="src/assets/logo_red.png" alt="LocAid Logo" class="logo">
        <button id="toggle-arrow-btn" class="button hidden" style="background-color: #990909;">Show Arrow</button>
        <button class="button-settings">‚ò∞</button>
    </header>

    <div class="content-contatiner">
        <div id="viewDiv" class="map-container">

            <div class="search-bar">
                <div id="list-destination"></div>
                <div class="search-bar-inner">
                    <input type="search" class="search-input" placeholder="Search fire stations or users..." />
                    <div class="search-icon-wrapper" id="search-icon-wrapper">
                        <img class="search-icon" src="src/assets/search.png" />
                    </div>
                </div>
            </div>
        </div>

        <div id="route-to-button">Route to</div>

        <div class="button-group">
            <!-- <div id="status">Status: Idle</div> -->
            <button id="filter-layers-btn" class="button">Filter Layers</button>
            <!-- <button id="test-compass-btn" class="button hidden" style="background-color: #34c759;">Test Compass</button> -->
           <!-- <button id="calibrate-compass-btn" class="button hidden" style="background-color: #ff9500;">Set North</button> -->
            <!-- <button id="startBtn" class="button">Share my location</button> -->
            <!-- <button id="responderBtn" class="button">Responder Mode</button>
            <button id="stopBtn" class="button hidden">Stop Tracking</button> -->
        </div>
    </main>    

    <div id="arrow-container" class="hidden">
        <img id="arrow" src="src/assets/arrow.png" alt="Direction Arrow">
    </div>

</body>
<script src="https://js.arcgis.com/4.29/"></script>
<script defer>
    // --- CONFIGURATION ---
    const SERVER_URL = `/location`;
    const SEND_INTERVAL_MS = 3000;

    // --- DOM ELEMENTS ---
    const startBtn = document.getElementById('startBtn');
    const responderBtn = document.getElementById('responderBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusDiv = document.getElementById('status');
    const arrowContainer = document.getElementById('arrow-container');
    const arrow = document.getElementById('arrow');
    const toggleArrowBtn = document.getElementById('toggle-arrow-btn');
    const testCompassBtn = document.getElementById('test-compass-btn');
    const calibrateCompassBtn = document.getElementById('calibrate-compass-btn');

    // --- CHECK URL PARAMETERS ---
    const urlParams = new URLSearchParams(window.location.search);
    const responderModeFromURL = urlParams.get('mode') === 'responder';

    // --- STATE ---
    let watchId = null;
    let deviceId = getOrSetDeviceId(); // Use a stable, persistent Device ID
    let isResponder = responderModeFromURL; // Start as responder if URL parameter is set
    let socket = null;
    let users = {}; // Store locations of other users
    let latestHeading = 0; // Store the compass heading
    let arrowVisible = false; // Track arrow visibility state
    let compassSetup = false; // Track if compass has been set up
    let userGraphics = {}; // Store user graphics by deviceId

    // --- FUNCTIONS ---
    function getOrSetDeviceId() {
        const storageKey = responderModeFromURL ? 'responderDeviceId' : 'trackerDeviceId';
        const storedId = localStorage.getItem(storageKey);
        if (storedId) {
            return storedId;
        }
        // Create a new ID if one isn't stored
        const prefix = responderModeFromURL ? 'responder' : 'user';
        const newId = `${prefix}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        localStorage.setItem(storageKey, newId);
        return newId;
    }

    function updateStatus(message, isError = false) {
        console.log(message);
        // statusDiv.textContent = `Status: ${message}`;
        // statusDiv.style.color = isError ? '#ff3b30' : '#333';    
    }

    async function sendLocation(position) {
        const { latitude, longitude, accuracy } = position.coords;
        const payload = {
            latitude,
            longitude,
            accuracy,
            deviceId,
            timestamp: new Date().toISOString(),
            type: isResponder ? 'responder' : 'user'
        };



        try {
            const response = await fetch(SERVER_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`Server responded with ${response.status}`);
        } catch (error) {
            updateStatus(`Error sending location: ${error.message}`, true);
        }
    }

    function startTracking(responderMode = false) {
        if (!navigator.geolocation) {
            updateStatus('Geolocation is not supported by your browser.', true);
            return;
        }
        isResponder = responderMode;
        console.log('üìç Starting tracking - isResponder:', isResponder, 'responderMode:', responderMode);
        updateStatus('Starting tracker... Waiting for position.');

        watchId = navigator.geolocation.watchPosition(
            (position) => {
                const { accuracy } = position.coords;
                updateStatus(`Tracking... (Accuracy: ${accuracy.toFixed(0)}m)`);
                window.latestPosition = position;
                if (isResponder) {
                    findNearestUserAndPoint();
                    // Update responder's own location on map
                    updateResponderOnMap(position);
                }
            },
            (error) => { updateStatus(`Geolocation error: ${error.message}`, true); },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );

        window.sendInterval = setInterval(() => {
            if (window.latestPosition) {
                sendLocation(window.latestPosition);
            }
        }, SEND_INTERVAL_MS);

        if (isResponder) {
            setupWebSocket();
            // Show the responder buttons
            toggleArrowBtn.classList.remove('hidden');
            if (testCompassBtn) testCompassBtn.classList.remove('hidden');
            if (calibrateCompassBtn) calibrateCompassBtn.classList.remove('hidden');
        }

        // startBtn.classList.add('hidden');
        // responderBtn.classList.add('hidden');
        // stopBtn.classList.remove('hidden');
    }

    function stopTracking() {
        if (watchId !== null) navigator.geolocation.clearWatch(watchId);
        if (window.sendInterval) clearInterval(window.sendInterval);
        if (socket) socket.close();
        // Remove the compass listener
        window.removeEventListener('deviceorientation', handleOrientation);

        watchId = null;
        isResponder = false;
        window.latestPosition = null;
        arrowVisible = false;
        compassSetup = false;

        // Reset UI elements
        arrowContainer.classList.add('hidden');
        toggleArrowBtn.classList.add('hidden');
        toggleArrowBtn.textContent = 'Show Arrow';
        toggleArrowBtn.style.backgroundColor = '#990909';
        if (testCompassBtn) testCompassBtn.classList.add('hidden');
        if (calibrateCompassBtn) calibrateCompassBtn.classList.add('hidden');
        updateStatus('Tracking stopped.');
    }

    function setupWebSocket() {
        const WEBSOCKET_URL = `wss://${window.location.host}`;
        socket = new WebSocket(WEBSOCKET_URL);

        socket.onmessage = (event) => {
            const locationData = JSON.parse(event.data);
            // We only care about standard users, not ourselves or other responders
            if (locationData.deviceId !== deviceId && locationData.type === 'user') {
                users[locationData.deviceId] = locationData;
                findNearestUserAndPoint();
                // Update user on map if map is available
                updateUserOnMap(locationData);
            }
        };

        socket.onclose = () => {
            updateStatus("Real-time connection lost.", true);
            arrowContainer.classList.add('hidden');
        };
    }

    // --- New Compass/Orientation Functions ---
    function setupDeviceOrientation() {
        console.log('üß≠ Setting up device orientation with user gesture...');
        
        return new Promise((resolve, reject) => {
            // Check for the iOS 13+ permission model
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                console.log('üß≠ iOS 13+ detected, requesting permission...');
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        console.log('üß≠ Permission result:', permissionState);
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            console.log('üß≠ Device orientation listener added for iOS');
                            compassSetup = true;
                            
                            // Test compass after setup
                            setTimeout(() => {
                                console.log('üß≠ After 2 seconds, latest heading:', latestHeading);
                                resolve();
                            }, 2000);
                        } else {
                            reject(new Error('Compass permission denied'));
                        }
                    })
                    .catch(error => {
                        console.error('üß≠ Permission error:', error);
                        reject(error);
                    });
            } else {
                // Handle non-iOS 13+ devices (Android, older iOS)
                console.log('üß≠ Non-iOS 13+ device, adding orientation listener...');
                window.addEventListener('deviceorientation', handleOrientation);
                
                // Also try absolute orientation for better compass on Android
                if ('DeviceOrientationEvent' in window && 'ondeviceorientationabsolute' in window) {
                    console.log('üß≠ Adding absolute orientation listener for Android...');
                    window.addEventListener('deviceorientationabsolute', handleOrientation);
                }
                
                compassSetup = true;
                
                // Test compass after setup
                setTimeout(() => {
                    console.log('üß≠ After 2 seconds, latest heading:', latestHeading);
                    if (latestHeading === 0) {
                        console.log('üß≠ WARNING: Compass may not be working - still showing 0¬∞');
                    }
                    resolve();
                }, 2000);
            }
        });
    }

    function handleOrientation(event) {
        // Use webkitCompassHeading if available (for iOS), otherwise use alpha
        let heading = event.alpha;
        if (typeof event.webkitCompassHeading !== "undefined") {
            heading = event.webkitCompassHeading; 
        }
        
        // Handle null/undefined values
        if (heading === null || heading === undefined) {
            heading = 0;
        }
        
        latestHeading = heading;
        
        // Debug: Show compass values on screen
        if (isResponder && arrowVisible) {
            console.log('üß≠ Compass - Alpha:', event.alpha, 'WebKit:', event.webkitCompassHeading, 'Using:', heading);
        }
    }

    function toggleArrow() {
        console.log('üéØ Toggle arrow clicked! Current state:', { arrowVisible, compassSetup, isResponder });
        
        if (!arrowVisible) {
            // Showing arrow - request compass permission first
            if (!compassSetup) {
                console.log('üß≠ Requesting compass access with user gesture...');
                setupDeviceOrientation().then(() => {
                    // Permission granted, show arrow
                    arrowVisible = true;
                    arrowContainer.classList.remove('hidden');
                    toggleArrowBtn.textContent = 'Hide Arrow';
                    toggleArrowBtn.style.backgroundColor = '#7a0707';
                    findNearestUserAndPoint();
                }).catch(error => {
                    console.error('üß≠ Failed to setup compass:', error);
                    updateStatus('Compass permission denied. Arrow will point assuming north is up.', true);
                    // Show arrow anyway, but it won't rotate with compass
                    arrowVisible = true;
                    arrowContainer.classList.remove('hidden');
                    toggleArrowBtn.textContent = 'Hide Arrow';
                    toggleArrowBtn.style.backgroundColor = '#7a0707';
                    findNearestUserAndPoint();
                });
            } else {
                // Compass already set up, just show arrow
                arrowVisible = true;
                arrowContainer.classList.remove('hidden');
                toggleArrowBtn.textContent = 'Hide Arrow';
                toggleArrowBtn.style.backgroundColor = '#7a0707';
                findNearestUserAndPoint();
            }
        } else {
            // Hiding arrow
            arrowVisible = false;
            arrowContainer.classList.add('hidden');
            toggleArrowBtn.textContent = 'Show Arrow';
            toggleArrowBtn.style.backgroundColor = '#990909';
        }
    }

    function testCompass() {
        alert(`Current compass reading:\n\nHeading: ${latestHeading}¬∞\n\nRotate your phone and try again to see if the value changes.\n\nIf it stays at 0¬∞, the compass isn't working.`);
    }

    function calibrateCompass() {
        if (!compassSetup) {
            alert('Please click "Show Arrow" first to request compass permission.');
            return;
        }
        
        alert(`Point your phone towards NORTH and click OK.\n\nCurrent reading: ${latestHeading}¬∞\n\nThis will calibrate the arrow direction.`);
        
        // For now, just show current reading - we can add manual offset later if needed
        console.log('üß≠ Manual calibration - current heading:', latestHeading);
    }

    function updateUserOnMap(userData) {
        // Only update map if we're in responder mode and have map objects available
        if (!isResponder || typeof window.Graphic === 'undefined' || typeof window.Point === 'undefined') {
            return;
        }

        try {
            const { latitude, longitude, deviceId: userDeviceId, accuracy } = userData;
            const point = new window.Point({ latitude, longitude });

            const backgroundSymbol = {
                type: "simple-marker",
                style: "circle",
                color: [6, 5, 5], // #060505
                size: "24px",
                outline: null
            };

            const iconSymbol = {
                type: "picture-marker",
                url: "src/assets/person.png",
                width: "18px",
                height: "18px"
            };

            if (userGraphics[userDeviceId]) {
                // Update existing graphics
                userGraphics[userDeviceId].background.geometry = point;
                userGraphics[userDeviceId].icon.geometry = point;
            } else if (window.graphicsLayer) {
                // Create new user graphics
                const backgroundGraphic = new window.Graphic({
                    geometry: point,
                    symbol: backgroundSymbol,
                    attributes: { type: "user-background" } // To help with hit-testing if needed
                });

                const iconGraphic = new window.Graphic({
                    geometry: point,
                    symbol: iconSymbol,
                    attributes: { 
                        type: "user", 
                        deviceId: userDeviceId,
                        accuracy: accuracy 
                    },
                    popupTemplate: {
                        title: "User: {deviceId}",
                        content: "Accuracy: {accuracy}m"
                    }
                });
                
                window.graphicsLayer.addMany([backgroundGraphic, iconGraphic]);
                userGraphics[userDeviceId] = { background: backgroundGraphic, icon: iconGraphic };
                console.log('üó∫Ô∏è Added user to map:', userDeviceId);
            }
        } catch (error) {
            console.log('üó∫Ô∏è Map not ready yet for user updates:', error);
        }
    }

    function updateResponderOnMap(position) {
        // Only update map if we're in responder mode and have map objects available
        if (!isResponder || typeof window.Graphic === 'undefined' || typeof window.Point === 'undefined') {
            return;
        }

        try {
            const { latitude, longitude, accuracy } = position.coords;
            const point = new window.Point({ latitude, longitude });

            const backgroundSymbol = {
                type: "simple-marker",
                style: "circle",
                color: [34, 24, 63], // #22183f
                size: "24px",
                outline: null
            };

            const iconSymbol = {
                type: "picture-marker",
                url: "src/assets/plus.png",
                width: "18px",
                height: "18px"
            };
            
            if (window.responderGraphics) {
                // Update existing responder graphic
                window.responderGraphics.background.geometry = point;
                window.responderGraphics.icon.geometry = point;
            } else if (window.graphicsLayer) {
                // Create new responder graphic
                const backgroundGraphic = new window.Graphic({
                    geometry: point,
                    symbol: backgroundSymbol
                });
                const iconGraphic = new window.Graphic({
                    geometry: point,
                    symbol: iconSymbol,
                    attributes: { 
                        type: "responder", 
                        deviceId: deviceId,
                        accuracy: accuracy 
                    }
                });
                window.graphicsLayer.addMany([backgroundGraphic, iconGraphic]);
                window.responderGraphics = { background: backgroundGraphic, icon: iconGraphic };
                console.log('üó∫Ô∏è Created responder graphic on map');
            }
        } catch (error) {
            console.log('üó∫Ô∏è Map not ready yet for responder updates:', error);
        }
    }

    function findNearestUserAndPoint() {
        if (!arrowVisible || !window.latestPosition || Object.keys(users).length === 0) {
            arrow.style.transform = 'rotate(0deg) scale(0)';
            return;
        }

        const myLat = window.latestPosition.coords.latitude;
        const myLon = window.latestPosition.coords.longitude;
        let nearestDist = Infinity;
        let nearestUser = null;

        for (const id in users) {
            const user = users[id];
            const dist = Math.sqrt(Math.pow(myLat - user.latitude, 2) + Math.pow(myLon - user.longitude, 2));
            if (dist < nearestDist) {
                nearestDist = dist;
                nearestUser = user;
            }
        }

        if (nearestUser) {
            const lat1 = myLat * Math.PI / 180;
            const lon1 = myLon * Math.PI / 180;
            const lat2 = nearestUser.latitude * Math.PI / 180;
            const lon2 = nearestUser.longitude * Math.PI / 180;
            
            const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
            const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; // Corrected bearing calculation

            // Apply the device's compass heading to orient the arrow correctly
            // Add 180¬∞ because the arrow image points down instead of up
            const rotation = bearing - latestHeading + 180;
            console.log('üéØ Arrow calc - Bearing:', bearing.toFixed(1), '¬∞ | Compass:', latestHeading, '¬∞ | Final rotation:', rotation.toFixed(1), '¬∞');
            arrow.style.transform = `rotate(${rotation}deg) scale(1)`;

        } else {
             arrow.style.transform = 'rotate(0deg) scale(0)';
        }
    }

    // Auto-start tracking in the appropriate mode
    console.log('üöÄ Starting tracker with:', { responderModeFromURL, deviceId });
    startTracking(responderModeFromURL);

    // Add event listener for responder buttons
    toggleArrowBtn.addEventListener('click', toggleArrow);
    if (testCompassBtn) testCompassBtn.addEventListener('click', testCompass);
    if (calibrateCompassBtn) calibrateCompassBtn.addEventListener('click', calibrateCompass);

    //         document.addEventListener('DOMContentLoaded', () => {
    // startBtn.addEventListener('click', () => startTracking(false));
    //         responderBtn.addEventListener('click', () => startTracking(true));
    //         stopBtn.addEventListener('click', stopTracking);
    //         });
    // --- EVENT LISTENERS ---

</script>

<script>
    // Initialize map only in responder mode
    if (responderModeFromURL) {
        console.log('üó∫Ô∏è Responder mode detected, initializing map...');
        require([
            "esri/config",
            "esri/WebMap",
            "esri/views/MapView",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/geometry/Point",
            "esri/widgets/LayerList"
                ], function(esriConfig, WebMap, MapView, GraphicsLayer, Graphic, Point, LayerList) {
            // Also load routing modules
            require([
                "esri/layers/RouteLayer",
                "esri/rest/support/Stop",
                "esri/geometry/projection",
                "esri/geometry/SpatialReference"
            ], function(RouteLayer, Stop, projection, SpatialReference) {
                
                try {
                    // Set API key
                    esriConfig.apiKey = "AAPTxy8BH1VEsoebNVZXo8HurJNkc1laRp1vAwT3-tXnuF3x-hGfL7b7jMe3CM0GiMyuTTg-lrFRdjvrAWsq9NCjJTcBWf_1bK0AoEE-eukjSiR7_41IaU8ZbnZytMHzhJvd87ZnvexVuj65yOBoclKr2N3ciauOPysAhdUze5Xm2KImfnxpA2Tnh9ANk5OTLlVMowDfQQ6RT5TIcg7um6QJUQi8VHORtLw0-sg5yUsCrVb1Hnp4zkT4zV-ZxpYG0_HAAT1_teoS1mtm";
                    
                    console.log('üó∫Ô∏è Starting map initialization for responder...');

                    // Route drawing function
                    window.drawRoute = async function(from, to) {
                        console.log('üõ£Ô∏è Drawing route from', from, 'to', to);
                        
                        const stops = [
                            new Stop({
                                geometry: { x: from.x, y: from.y },
                                name: from.name,
                            }),
                            new Stop({
                                geometry: { x: to.x, y: to.y },
                                name: to.name,
                            }),
                        ];
                        
                        const routeLayer = new RouteLayer({
                            stops,
                        });

                        map.add(routeLayer);

                        try {
                            const results = await routeLayer.solve({ 
                                apiKey: esriConfig.apiKey 
                            });
                            routeLayer.update(results);
                            window.mapView.goTo(routeLayer.routeInfo.geometry);
                            console.log('üõ£Ô∏è Route created successfully');
                        } catch (error) {
                            console.error('üõ£Ô∏è Route creation failed:', error);
                            alert('Failed to create route. Please try again.');
                        }
                    };

                    // Search functionality setup
                    window.setupSearchFunctionality = function(view) {
                        const destination = document.querySelector("#list-destination");
                        const searchInput = document.querySelector(".search-input");
                        
                        if (!searchInput) return;

                        searchInput.addEventListener("keydown", async (event) => {
                            if (event.key === "Enter" && searchInput.value.trim()) {
                                const searchTerm = searchInput.value.trim().toLowerCase();
                                console.log('üîç Searching for:', searchTerm);
                                
                                // Clear previous results
                                destination.innerHTML = '';
                                destination.style.display = "none";
                                
                                const results = [];
                                
                                // Search fire stations
                                const fireStationsResults = await searchFireStations(view, searchTerm);
                                results.push(...fireStationsResults);
                                
                                // Search users if in responder mode
                                if (isResponder) {
                                    const userResults = searchUsers(searchTerm);
                                    results.push(...userResults);
                                }
                                
                                // Display results
                                if (results.length > 0) {
                                    displaySearchResults(results, destination);
                                } else {
                                    destination.innerHTML = '<div class="destination-item">No results found</div>';
                                    destination.style.display = "block";
                                }
                            }
                        });

                        // Hide results when clicking outside
                        document.addEventListener('click', (event) => {
                            if (!event.target.closest('.search-bar')) {
                                destination.style.display = "none";
                            }
                        });
                    };

                    // Search fire stations
                    window.searchFireStations = async function(view, searchTerm) {
                        const fireStationsLayer = view.map.allLayers.find(layer => layer.title === "Fire Stations");
                        
                        if (!fireStationsLayer || fireStationsLayer.type !== "feature") {
                            return [];
                        }

                        await projection.load();
                        
                        const query = fireStationsLayer.createQuery();
                        query.where = "1=1";
                        query.outFields = ["*"];
                        query.returnGeometry = true;

                        try {
                            const result = await fireStationsLayer.queryFeatures(query);
                            const wgs84 = SpatialReference.WGS84;

                            const coords = result.features.map((f) => {
                                const pt = projection.project(f.geometry, wgs84);
                                return {
                                    latitude: pt.latitude,
                                    longitude: pt.longitude,
                                    address: f.attributes.ADDRESS || 'Unknown Address',
                                    city: f.attributes.CITY || 'Unknown City',
                                    type: 'fire_station'
                                };
                            });

                            // Filter by search term
                            const filtered = coords.filter(item => 
                                item.city.toLowerCase().includes(searchTerm) ||
                                item.address.toLowerCase().includes(searchTerm)
                            );

                            // Sort by distance if we have current location
                            if (window.currentLocation) {
                                filtered.forEach(item => {
                                    const distance = Math.sqrt(
                                        Math.pow(window.currentLocation.y - item.latitude, 2) + 
                                        Math.pow(window.currentLocation.x - item.longitude, 2)
                                    );
                                    item.distance = distance;
                                });
                                filtered.sort((a, b) => a.distance - b.distance);
                            }

                            return filtered.slice(0, 10);
                        } catch (error) {
                            console.error('üîç Fire station search failed:', error);
                            return [];
                        }
                    };

                    // Search users
                    window.searchUsers = function(searchTerm) {
                        const userResults = [];
                        
                        Object.keys(users).forEach(deviceId => {
                            const user = users[deviceId];
                            if (deviceId.toLowerCase().includes(searchTerm) || 
                                user.type === 'user') {
                                
                                let distance = null;
                                if (window.currentLocation) {
                                    distance = Math.sqrt(
                                        Math.pow(window.currentLocation.y - user.latitude, 2) + 
                                        Math.pow(window.currentLocation.x - user.longitude, 2)
                                    );
                                }
                                
                                userResults.push({
                                    deviceId: deviceId,
                                    latitude: user.latitude,
                                    longitude: user.longitude,
                                    type: 'user',
                                    distance: distance,
                                    name: `User ${deviceId.slice(-6)}`
                                });
                            }
                        });
                        
                        if (window.currentLocation) {
                            userResults.sort((a, b) => (a.distance || 0) - (b.distance || 0));
                        }
                        
                        return userResults.slice(0, 5);
                    };

                    // Display search results
                    window.displaySearchResults = function(results, destination) {
                        destination.innerHTML = '';
                        
                        results.forEach((item, index) => {
                            const div = document.createElement("div");
                            div.className = "destination-item";
                            
                            if (item.type === 'fire_station') {
                                div.innerHTML = `
                                    <strong>üöí ${index + 1}. ${item.city}</strong><br>
                                    ${item.address}<br>
                                    ${item.distance ? `Distance: ${(item.distance * 111).toFixed(2)} km` : ''}
                                `;
                                div.addEventListener("click", () => {
                                    window.drawRoute(
                                        { x: window.currentLocation.x, y: window.currentLocation.y, name: "My Location" }, 
                                        { x: item.longitude, y: item.latitude, name: item.city }
                                    );
                                    destination.style.display = "none";
                                });
                            } else if (item.type === 'user') {
                                div.innerHTML = `
                                    <strong>üë§ ${item.name}</strong><br>
                                    Device: ${item.deviceId}<br>
                                    ${item.distance ? `Distance: ${(item.distance * 111).toFixed(2)} km` : ''}
                                `;
                                div.addEventListener("click", () => {
                                    window.drawRoute(
                                        { x: window.currentLocation.x, y: window.currentLocation.y, name: "My Location" }, 
                                        { x: item.longitude, y: item.latitude, name: item.name }
                                    );
                                    destination.style.display = "none";
                                });
                            }
                            
                            destination.appendChild(div);
                        });
                        
                        destination.style.display = "block";
                    };

                    // Map click handler setup
                    window.setupMapClickHandler = function(view) {
                        const goToButton = document.getElementById("route-to-button");
                        
                        view.on("click", function (event) {
                            view.hitTest(event).then(function (response) {
                                const fireStations = response.results.filter(r => 
                                    r.graphic.layer && r.graphic.layer.title === "Fire Stations"
                                );
                                const userGraphics = response.results.filter(r => 
                                    r.graphic && r.graphic.attributes && r.graphic.attributes.type === "user"
                                );
                                
                                if (fireStations.length > 0 || userGraphics.length > 0) {
                                    goToButton.style.display = "block";
                                    
                                    // Store the target for routing
                                    if (fireStations.length > 0) {
                                        window.routeTarget = {
                                            x: fireStations[0].mapPoint.longitude,
                                            y: fireStations[0].mapPoint.latitude,
                                            name: "Fire Station"
                                        };
                                    } else {
                                        const userGraphic = userGraphics[0];
                                        window.routeTarget = {
                                            x: userGraphic.mapPoint.longitude,
                                            y: userGraphic.mapPoint.latitude,
                                            name: `User ${userGraphic.graphic.attributes.deviceId?.slice(-6) || 'Unknown'}`
                                        };
                                    }
                                } else {
                                    goToButton.style.display = "none";
                                }
                            });
                        });

                        // Route button click handler
                        goToButton.addEventListener("click", () => {
                            if (window.routeTarget && window.currentLocation) {
                                window.drawRoute(
                                    { x: window.currentLocation.x, y: window.currentLocation.y, name: "My Location" },
                                    window.routeTarget
                                );
                                goToButton.style.display = "none";
                            }
                        });
                    };
            
            // Make these available globally for the user update functions
            window.Graphic = Graphic;
            window.Point = Point;

            const map = new WebMap({
                portalItem: {
                    id: "743d191198274f03920cb6e399f19f8b",
                },
            });
            
            console.log('üó∫Ô∏è WebMap created, loading...');

            const graphicsLayer = new GraphicsLayer();
            map.add(graphicsLayer);
            window.graphicsLayer = graphicsLayer; // Make available globally
            let userGraphic = null;

                // Create responder graphic that will be updated by the main tracking function
            window.responderGraphics = null; // Make available globally


            console.log('üó∫Ô∏è Creating MapView...');
            
            // Check if viewDiv exists
            const viewDiv = document.getElementById('viewDiv');
            if (!viewDiv) {
                console.error('üó∫Ô∏è viewDiv container not found!');
                return;
            }
                         console.log('üó∫Ô∏è viewDiv container found:', viewDiv);
            
            const view = new MapView({
                container: "viewDiv",
                map: map,
                extent: {
                    xmin: -118.23849978435393,
                    ymin: 34.13414868681906,
                    xmax: -118.00438397317032,
                    ymax: 34.25355759833813,
                    spatialReference: 4326,
                }
            });
            
            // Make view available globally for routing
            window.mapView = view;
            
            view.when(() => {
                console.log('üó∫Ô∏è MapView loaded successfully!');
                
                // Set up click handler for routing
                setupMapClickHandler(view);
                
                // Set up search functionality
                setupSearchFunctionality(view);
            }).catch((error) => {
                console.error('üó∫Ô∏è MapView failed to load:', error);
            });

            const layerList = new LayerList({
                view: view
            });

            let isLayerListVisible = true;

            const filterBtn = document.getElementById('filter-layers-btn');

            filterBtn.addEventListener('click', function () {
                if (isLayerListVisible)
                    view.ui.remove(layerList);
                else
                    view.ui.add(layerList, {
                        position: "top-right"
                    });

                isLayerListVisible = !isLayerListVisible;
            });

            let currentLocation;
            
            // Make currentLocation available globally for search and routing
            window.currentLocation = null;

            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        const latitude = position.coords.latitude;
                        const longitude = position.coords.longitude;

                        console.log(latitude, longitude);
                        currentLocation = { x: longitude, y: latitude };
                        window.currentLocation = currentLocation;
                        
                        // Center map on current location
                        view.goTo({
                            center: [longitude, latitude],
                            zoom: 15
                        });
                    }
                );
            }

            // Make currentLocation available globally
            window.currentLocation = currentLocation;

            // Note: Routing functionality requires additional imports (RouteLayer, Stop)
            // For now, focusing on the basic map display with user locations
            
            console.log('üó∫Ô∏è Responder map initialized successfully');
            
            } catch (error) {
                console.error('üó∫Ô∏è Error initializing responder map:', error);
            }
        }); // Close inner require function for routing modules
        }); // Close outer require function
    } // Close responderModeFromURL check
</script>

</html>
