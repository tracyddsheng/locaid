<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="styles/Button.css">
    <title>Location Tracker</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; background-color: #f0f0f0; color: #333; text-align: center; }
        #status { margin: 20px; padding: 10px 20px; border-radius: 8px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-width: 280px; }
        .button-group { display: flex; gap: 10px; }
        button { font-size: 1.2em; padding: 15px 30px; border-radius: 8px; border: none; cursor: pointer; color: white; transition: background-color 0.2s; }
        .hidden { display: none; }
        #arrow-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; pointer-events: none; z-index: 10; }
        #arrow { font-size: 100px; text-shadow: 0 0 10px rgba(0,0,0,0.5); transition: transform 0.2s ease-out; }
    </style>
</head>
<body>

    <h1>Location Tracker</h1>
    <div id="status">Status: Idle</div>
    <div class="button-group">
        <button id="startBtn" class="button">Track Me</button>
        <button id="responderBtn" class="button">Responder Mode</button>
        <button id="stopBtn" class="button hidden">Stop Tracking</button>
    </div>

    <div id="arrow-container" class="hidden">
        <div id="arrow">⬆️</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const SERVER_URL = `/location`;
        const SEND_INTERVAL_MS = 3000;

        // --- DOM ELEMENTS ---
        const startBtn = document.getElementById('startBtn');
        const responderBtn = document.getElementById('responderBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const arrowContainer = document.getElementById('arrow-container');
        const arrow = document.getElementById('arrow');

        // --- STATE ---
        let watchId = null;
        let deviceId = getOrSetDeviceId(); // Use a stable, persistent Device ID
        let isResponder = false;
        let socket = null;
        let users = {}; // Store locations of other users
        let latestHeading = 0; // Store the compass heading

        // --- FUNCTIONS ---
        function getOrSetDeviceId() {
            const storedId = localStorage.getItem('trackerDeviceId');
            if (storedId) {
                return storedId;
            }
            // Create a new ID if one isn't stored
            const newId = `device-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
            localStorage.setItem('trackerDeviceId', newId);
            return newId;
        }

        function updateStatus(message, isError = false) {
            console.log(message);
            statusDiv.textContent = `Status: ${message}`;
            statusDiv.style.color = isError ? '#ff3b30' : '#333';
        }

        async function sendLocation(position) {
            const { latitude, longitude, accuracy } = position.coords;
            const payload = {
                latitude,
                longitude,
                accuracy,
                deviceId,
                timestamp: new Date().toISOString(),
                type: isResponder ? 'responder' : 'user'
            };

            try {
                const response = await fetch(SERVER_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Server responded with ${response.status}`);
            } catch (error) {
                updateStatus(`Error sending location: ${error.message}`, true);
            }
        }
        
        function startTracking(responderMode = false) {
            if (!navigator.geolocation) {
                updateStatus('Geolocation is not supported by your browser.', true);
                return;
            }
            isResponder = responderMode;
            updateStatus('Starting tracker... Waiting for position.');

            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const { accuracy } = position.coords;
                    updateStatus(`Tracking... (Accuracy: ${accuracy.toFixed(0)}m)`);
                    window.latestPosition = position; 
                    if (isResponder) {
                        findNearestUserAndPoint();
                    }
                },
                (error) => { updateStatus(`Geolocation error: ${error.message}`, true); },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );

            window.sendInterval = setInterval(() => {
                if (window.latestPosition) {
                    sendLocation(window.latestPosition);
                }
            }, SEND_INTERVAL_MS);

            if (isResponder) {
                // Request compass permissions and set up listeners
                setupDeviceOrientation(); 
                setupWebSocket();
                arrowContainer.classList.remove('hidden');
            }

            startBtn.classList.add('hidden');
            responderBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
        }

        function stopTracking() {
            if (watchId !== null) navigator.geolocation.clearWatch(watchId);
            if (window.sendInterval) clearInterval(window.sendInterval);
            if (socket) socket.close();
            // Remove the compass listener
            window.removeEventListener('deviceorientation', handleOrientation);

            watchId = null;
            isResponder = false;
            window.latestPosition = null;

            startBtn.classList.remove('hidden');
            responderBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            arrowContainer.classList.add('hidden');
            updateStatus('Tracking stopped.');
        }

        function setupWebSocket() {
            const WEBSOCKET_URL = `wss://${window.location.host}`;
            socket = new WebSocket(WEBSOCKET_URL);

            socket.onmessage = (event) => {
                const locationData = JSON.parse(event.data);
                // We only care about standard users, not ourselves or other responders
                if (locationData.deviceId !== deviceId && locationData.type === 'user') {
                    users[locationData.deviceId] = locationData;
                    findNearestUserAndPoint();
                }
            };

            socket.onclose = () => {
                updateStatus("Real-time connection lost.", true);
                arrowContainer.classList.add('hidden');
            };
        }

        // --- New Compass/Orientation Functions ---
        function setupDeviceOrientation() {
            // Check for the iOS 13+ permission model
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        } else {
                            updateStatus('Compass permission was not granted.', true);
                        }
                    })
                    .catch(error => {
                        updateStatus('Error requesting compass permission.', true)
                        console.error(error);
                    });
            } else {
                // Handle non-iOS 13+ devices
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        function handleOrientation(event) {
            // Use webkitCompassHeading if available (for iOS), otherwise use alpha
            let heading = event.alpha;
            if (typeof event.webkitCompassHeading !== "undefined") {
                heading = event.webkitCompassHeading; 
            }
            latestHeading = heading;
        }

        function findNearestUserAndPoint() {
            if (!window.latestPosition || Object.keys(users).length === 0) {
                arrow.style.transform = 'rotate(0deg) scale(0)';
                return;
            }

            const myLat = window.latestPosition.coords.latitude;
            const myLon = window.latestPosition.coords.longitude;
            let nearestDist = Infinity;
            let nearestUser = null;

            for (const id in users) {
                const user = users[id];
                const dist = Math.sqrt(Math.pow(myLat - user.latitude, 2) + Math.pow(myLon - user.longitude, 2));
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestUser = user;
                }
            }

            if (nearestUser) {
                const lat1 = myLat * Math.PI / 180;
                const lon1 = myLon * Math.PI / 180;
                const lat2 = nearestUser.latitude * Math.PI / 180;
                const lon2 = nearestUser.longitude * Math.PI / 180;
                
                const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
                const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
                const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; // Corrected bearing calculation

                // Apply the device's compass heading to orient the arrow correctly
                const rotation = bearing - latestHeading;
                arrow.style.transform = `rotate(${rotation}deg) scale(1)`;

            } else {
                 arrow.style.transform = 'rotate(0deg) scale(0)';
            }
        }

        // --- EVENT LISTENERS ---
        startBtn.addEventListener('click', () => startTracking(false));
        responderBtn.addEventListener('click', () => startTracking(true));
        stopBtn.addEventListener('click', stopTracking);
    </script>
</body>
</html>
