<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="styles/Button.css">
    <link rel="stylesheet" href="https://js.arcgis.com/4.29/esri/themes/light/main.css" />
    <title>Location Tracker</title>
    <style>
        body {
            font-family: 'Barlow';
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            text-align: center;
        }

        #status {
            margin: 20px;
            padding: 10px 20px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 280px;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            font-size: 1.2em;
            padding: 15px 30px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            color: white;
            transition: background-color 0.2s;
        }

        .hidden {
            display: none;
        }

        #arrow-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        #arrow {
            width: 80px;
            height: 80px;
            transition: transform 0.2s ease-out;
            filter: drop-shadow(0 0 10px rgba(153, 9, 9, 0.5));
        }

        .button-group {
            position: absolute;
            top: 8px;
            right: 8px;
        }
    </style>

    <link rel="stylesheet" href="styles/SearchBar.css">

    <title>Location Tracker</title>


    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            width: 95%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .logo {
            height: 50px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            height: 100%;
        }

        .welcome-text {
            margin-bottom: 2rem;
        }

        .button-container {
            display: flex;
            gap: 1rem;
            flex-direction: column;
            width: 100%;
            max-width: 300px;
        }

        .content-contatiner {
            width: 100%;
            height: 100%;

            position: relative;
        }

        .map-container {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            flex: 1;
        }

        #viewDiv {
            width: 100%;
            height: 100%;
        }

        #filter-layers-btn {
            background-color: #42454A;
        }

        #route-to-button {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: solid 1px black;

            border-radius: 5px;

            padding: 10px;
        }
    </style>
</head>

<body>
    <header class="header" style="background-color: white;">
        <img src="src/assets/logo_red.png" alt="LocAid Logo" class="logo">
        <button id="toggle-arrow-btn" class="button hidden" style="background-color: #990909;">Show Arrow</button>
        <button class="button-settings">‚ò∞</button>
    </header>

    <div class="content-contatiner">
        <div id="viewDiv" class="map-container">

            <!-- <div class="search-bar">
                <div class="search-bar-inner">
                    <input type="search" class="search-input" placeholder="Search location..." />
                    <img class="search-icon" src="src/assets/search.png"></img>
                </div>
            </div> -->
        </div>

        <div id="route-to-button">Route to</div>

        <div class="button-group">
            <!-- <div id="status">Status: Idle</div> -->
            <button id="filter-layers-btn" class="button">Filter Layers</button>
            <!-- <button id="test-compass-btn" class="button hidden" style="background-color: #34c759;">Test Compass</button> -->
           <!-- <button id="calibrate-compass-btn" class="button hidden" style="background-color: #ff9500;">Set North</button> -->
            <!-- <button id="startBtn" class="button">Share my location</button> -->
            <!-- <button id="responderBtn" class="button">Responder Mode</button>
            <button id="stopBtn" class="button hidden">Stop Tracking</button> -->
        </div>
    </main>    

    <div id="arrow-container" class="hidden">
        <img id="arrow" src="src/assets/arrow.png" alt="Direction Arrow">
    </div>

</body>
<script src="https://js.arcgis.com/4.29/"></script>
<script defer>
    // --- CONFIGURATION ---
    const SERVER_URL = `/location`;
    const SEND_INTERVAL_MS = 3000;

    // --- DOM ELEMENTS ---
    const startBtn = document.getElementById('startBtn');
    const responderBtn = document.getElementById('responderBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusDiv = document.getElementById('status');
    const arrowContainer = document.getElementById('arrow-container');
    const arrow = document.getElementById('arrow');
    const toggleArrowBtn = document.getElementById('toggle-arrow-btn');
    const testCompassBtn = document.getElementById('test-compass-btn');
    const calibrateCompassBtn = document.getElementById('calibrate-compass-btn');

    // --- CHECK URL PARAMETERS ---
    const urlParams = new URLSearchParams(window.location.search);
    const responderModeFromURL = urlParams.get('mode') === 'responder';

    // --- STATE ---
    let watchId = null;
    let deviceId = getOrSetDeviceId(); // Use a stable, persistent Device ID
    let isResponder = responderModeFromURL; // Start as responder if URL parameter is set
    let socket = null;
    let users = {}; // Store locations of other users
    let latestHeading = 0; // Store the compass heading
    let arrowVisible = false; // Track arrow visibility state
    let compassSetup = false; // Track if compass has been set up
    let userGraphics = {}; // Store user graphics by deviceId

    // --- FUNCTIONS ---
    function getOrSetDeviceId() {
        const storageKey = responderModeFromURL ? 'responderDeviceId' : 'trackerDeviceId';
        const storedId = localStorage.getItem(storageKey);
        if (storedId) {
            return storedId;
        }
        // Create a new ID if one isn't stored
        const prefix = responderModeFromURL ? 'responder' : 'user';
        const newId = `${prefix}_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        localStorage.setItem(storageKey, newId);
        return newId;
    }

    function updateStatus(message, isError = false) {
        console.log(message);
        // statusDiv.textContent = `Status: ${message}`;
        // statusDiv.style.color = isError ? '#ff3b30' : '#333';    
    }

    async function sendLocation(position) {
        const { latitude, longitude, accuracy } = position.coords;
        const payload = {
            latitude,
            longitude,
            accuracy,
            deviceId,
            timestamp: new Date().toISOString(),
            type: isResponder ? 'responder' : 'user'
        };



        try {
            const response = await fetch(SERVER_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`Server responded with ${response.status}`);
        } catch (error) {
            updateStatus(`Error sending location: ${error.message}`, true);
        }
    }

    function startTracking(responderMode = false) {
        if (!navigator.geolocation) {
            updateStatus('Geolocation is not supported by your browser.', true);
            return;
        }
        isResponder = responderMode;
        console.log('üìç Starting tracking - isResponder:', isResponder, 'responderMode:', responderMode);
        updateStatus('Starting tracker... Waiting for position.');

        watchId = navigator.geolocation.watchPosition(
            (position) => {
                const { accuracy } = position.coords;
                updateStatus(`Tracking... (Accuracy: ${accuracy.toFixed(0)}m)`);
                window.latestPosition = position;
                if (isResponder) {
                    findNearestUserAndPoint();
                    // Update responder's own location on map
                    updateResponderOnMap(position);
                }
            },
            (error) => { updateStatus(`Geolocation error: ${error.message}`, true); },
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );

        window.sendInterval = setInterval(() => {
            if (window.latestPosition) {
                sendLocation(window.latestPosition);
            }
        }, SEND_INTERVAL_MS);

        if (isResponder) {
            setupWebSocket();
            // Show the responder buttons
            toggleArrowBtn.classList.remove('hidden');
            if (testCompassBtn) testCompassBtn.classList.remove('hidden');
            if (calibrateCompassBtn) calibrateCompassBtn.classList.remove('hidden');
        }

        // startBtn.classList.add('hidden');
        // responderBtn.classList.add('hidden');
        // stopBtn.classList.remove('hidden');
    }

    function stopTracking() {
        if (watchId !== null) navigator.geolocation.clearWatch(watchId);
        if (window.sendInterval) clearInterval(window.sendInterval);
        if (socket) socket.close();
        // Remove the compass listener
        window.removeEventListener('deviceorientation', handleOrientation);

        watchId = null;
        isResponder = false;
        window.latestPosition = null;
        arrowVisible = false;
        compassSetup = false;

        // Reset UI elements
        arrowContainer.classList.add('hidden');
        toggleArrowBtn.classList.add('hidden');
        toggleArrowBtn.textContent = 'Show Arrow';
        toggleArrowBtn.style.backgroundColor = '#990909';
        if (testCompassBtn) testCompassBtn.classList.add('hidden');
        if (calibrateCompassBtn) calibrateCompassBtn.classList.add('hidden');
        updateStatus('Tracking stopped.');
    }

    function setupWebSocket() {
        const WEBSOCKET_URL = `wss://${window.location.host}`;
        socket = new WebSocket(WEBSOCKET_URL);

        socket.onmessage = (event) => {
            const locationData = JSON.parse(event.data);
            // We only care about standard users, not ourselves or other responders
            if (locationData.deviceId !== deviceId && locationData.type === 'user') {
                users[locationData.deviceId] = locationData;
                findNearestUserAndPoint();
                // Update user on map if map is available
                updateUserOnMap(locationData);
            }
        };

        socket.onclose = () => {
            updateStatus("Real-time connection lost.", true);
            arrowContainer.classList.add('hidden');
        };
    }

    // --- New Compass/Orientation Functions ---
    function setupDeviceOrientation() {
        console.log('üß≠ Setting up device orientation with user gesture...');
        
        return new Promise((resolve, reject) => {
            // Check for the iOS 13+ permission model
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                console.log('üß≠ iOS 13+ detected, requesting permission...');
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        console.log('üß≠ Permission result:', permissionState);
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            console.log('üß≠ Device orientation listener added for iOS');
                            compassSetup = true;
                            
                            // Test compass after setup
                            setTimeout(() => {
                                console.log('üß≠ After 2 seconds, latest heading:', latestHeading);
                                resolve();
                            }, 2000);
                        } else {
                            reject(new Error('Compass permission denied'));
                        }
                    })
                    .catch(error => {
                        console.error('üß≠ Permission error:', error);
                        reject(error);
                    });
            } else {
                // Handle non-iOS 13+ devices (Android, older iOS)
                console.log('üß≠ Non-iOS 13+ device, adding orientation listener...');
                window.addEventListener('deviceorientation', handleOrientation);
                
                // Also try absolute orientation for better compass on Android
                if ('DeviceOrientationEvent' in window && 'ondeviceorientationabsolute' in window) {
                    console.log('üß≠ Adding absolute orientation listener for Android...');
                    window.addEventListener('deviceorientationabsolute', handleOrientation);
                }
                
                compassSetup = true;
                
                // Test compass after setup
                setTimeout(() => {
                    console.log('üß≠ After 2 seconds, latest heading:', latestHeading);
                    if (latestHeading === 0) {
                        console.log('üß≠ WARNING: Compass may not be working - still showing 0¬∞');
                    }
                    resolve();
                }, 2000);
            }
        });
    }

    function handleOrientation(event) {
        // Use webkitCompassHeading if available (for iOS), otherwise use alpha
        let heading = event.alpha;
        if (typeof event.webkitCompassHeading !== "undefined") {
            heading = event.webkitCompassHeading; 
        }
        
        // Handle null/undefined values
        if (heading === null || heading === undefined) {
            heading = 0;
        }
        
        latestHeading = heading;
        
        // Debug: Show compass values on screen
        if (isResponder && arrowVisible) {
            console.log('üß≠ Compass - Alpha:', event.alpha, 'WebKit:', event.webkitCompassHeading, 'Using:', heading);
        }
    }

    function toggleArrow() {
        console.log('üéØ Toggle arrow clicked! Current state:', { arrowVisible, compassSetup, isResponder });
        
        if (!arrowVisible) {
            // Showing arrow - request compass permission first
            if (!compassSetup) {
                console.log('üß≠ Requesting compass access with user gesture...');
                setupDeviceOrientation().then(() => {
                    // Permission granted, show arrow
                    arrowVisible = true;
                    arrowContainer.classList.remove('hidden');
                    toggleArrowBtn.textContent = 'Hide Arrow';
                    toggleArrowBtn.style.backgroundColor = '#7a0707';
                    findNearestUserAndPoint();
                }).catch(error => {
                    console.error('üß≠ Failed to setup compass:', error);
                    updateStatus('Compass permission denied. Arrow will point assuming north is up.', true);
                    // Show arrow anyway, but it won't rotate with compass
                    arrowVisible = true;
                    arrowContainer.classList.remove('hidden');
                    toggleArrowBtn.textContent = 'Hide Arrow';
                    toggleArrowBtn.style.backgroundColor = '#7a0707';
                    findNearestUserAndPoint();
                });
            } else {
                // Compass already set up, just show arrow
                arrowVisible = true;
                arrowContainer.classList.remove('hidden');
                toggleArrowBtn.textContent = 'Hide Arrow';
                toggleArrowBtn.style.backgroundColor = '#7a0707';
                findNearestUserAndPoint();
            }
        } else {
            // Hiding arrow
            arrowVisible = false;
            arrowContainer.classList.add('hidden');
            toggleArrowBtn.textContent = 'Show Arrow';
            toggleArrowBtn.style.backgroundColor = '#990909';
        }
    }

    function testCompass() {
        alert(`Current compass reading:\n\nHeading: ${latestHeading}¬∞\n\nRotate your phone and try again to see if the value changes.\n\nIf it stays at 0¬∞, the compass isn't working.`);
    }

    function calibrateCompass() {
        if (!compassSetup) {
            alert('Please click "Show Arrow" first to request compass permission.');
            return;
        }
        
        alert(`Point your phone towards NORTH and click OK.\n\nCurrent reading: ${latestHeading}¬∞\n\nThis will calibrate the arrow direction.`);
        
        // For now, just show current reading - we can add manual offset later if needed
        console.log('üß≠ Manual calibration - current heading:', latestHeading);
    }

    function updateUserOnMap(userData) {
        // Only update map if we're in responder mode and have map objects available
        if (!isResponder || typeof window.Graphic === 'undefined' || typeof window.Point === 'undefined') {
            return;
        }

        try {
            const { latitude, longitude, deviceId: userDeviceId, accuracy } = userData;
            
            if (userGraphics[userDeviceId]) {
                // Update existing user graphic
                userGraphics[userDeviceId].geometry = new window.Point({ latitude, longitude });
            } else if (window.graphicsLayer) {
                // Create new user graphic
                const userGraphic = new window.Graphic({
                    geometry: new window.Point({ latitude, longitude }),
                    symbol: {
                        type: "simple-marker",
                        color: [226, 119, 40], // Orange for users
                        size: "14px",
                        outline: { color: "white", width: 2 }
                    },
                    attributes: { 
                        type: "user", 
                        deviceId: userDeviceId,
                        accuracy: accuracy 
                    },
                    popupTemplate: {
                        title: "User: {deviceId}",
                        content: "Accuracy: {accuracy}m"
                    }
                });
                
                window.graphicsLayer.add(userGraphic);
                userGraphics[userDeviceId] = userGraphic;
                console.log('üó∫Ô∏è Added user to map:', userDeviceId);
            }
        } catch (error) {
            console.log('üó∫Ô∏è Map not ready yet for user updates:', error);
        }
    }

    function updateResponderOnMap(position) {
        // Only update map if we're in responder mode and have map objects available
        if (!isResponder || typeof window.Graphic === 'undefined' || typeof window.Point === 'undefined') {
            return;
        }

        try {
            const { latitude, longitude, accuracy } = position.coords;
            
            if (window.userGraphic) {
                // Update existing responder graphic
                window.userGraphic.geometry = new window.Point({ latitude, longitude });
            } else if (window.graphicsLayer) {
                // Create new responder graphic
                window.userGraphic = new window.Graphic({
                    geometry: new window.Point({ latitude, longitude }),
                    symbol: {
                        type: "simple-marker",
                        color: [0, 122, 194], // Blue for responder
                        size: "16px",
                        outline: { color: "white", width: 2 }
                    },
                    attributes: { 
                        type: "responder", 
                        deviceId: deviceId,
                        accuracy: accuracy 
                    }
                });
                window.graphicsLayer.add(window.userGraphic);
                console.log('üó∫Ô∏è Created responder graphic on map');
            }
        } catch (error) {
            console.log('üó∫Ô∏è Map not ready yet for responder updates:', error);
        }
    }

    function findNearestUserAndPoint() {
        if (!arrowVisible || !window.latestPosition || Object.keys(users).length === 0) {
            arrow.style.transform = 'rotate(0deg) scale(0)';
            return;
        }

        const myLat = window.latestPosition.coords.latitude;
        const myLon = window.latestPosition.coords.longitude;
        let nearestDist = Infinity;
        let nearestUser = null;

        for (const id in users) {
            const user = users[id];
            const dist = Math.sqrt(Math.pow(myLat - user.latitude, 2) + Math.pow(myLon - user.longitude, 2));
            if (dist < nearestDist) {
                nearestDist = dist;
                nearestUser = user;
            }
        }

        if (nearestUser) {
            const lat1 = myLat * Math.PI / 180;
            const lon1 = myLon * Math.PI / 180;
            const lat2 = nearestUser.latitude * Math.PI / 180;
            const lon2 = nearestUser.longitude * Math.PI / 180;
            
            const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
            const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; // Corrected bearing calculation

            // Apply the device's compass heading to orient the arrow correctly
            // Add 180¬∞ because the arrow image points down instead of up
            const rotation = bearing - latestHeading + 180;
            console.log('üéØ Arrow calc - Bearing:', bearing.toFixed(1), '¬∞ | Compass:', latestHeading, '¬∞ | Final rotation:', rotation.toFixed(1), '¬∞');
            arrow.style.transform = `rotate(${rotation}deg) scale(1)`;

        } else {
             arrow.style.transform = 'rotate(0deg) scale(0)';
        }
    }

    // Auto-start tracking in the appropriate mode
    console.log('üöÄ Starting tracker with:', { responderModeFromURL, deviceId });
    startTracking(responderModeFromURL);

    // Add event listener for responder buttons
    toggleArrowBtn.addEventListener('click', toggleArrow);
    if (testCompassBtn) testCompassBtn.addEventListener('click', testCompass);
    if (calibrateCompassBtn) calibrateCompassBtn.addEventListener('click', calibrateCompass);

    //         document.addEventListener('DOMContentLoaded', () => {
    // startBtn.addEventListener('click', () => startTracking(false));
    //         responderBtn.addEventListener('click', () => startTracking(true));
    //         stopBtn.addEventListener('click', stopTracking);
    //         });
    // --- EVENT LISTENERS ---

</script>

<script>
    // Initialize map only in responder mode
    if (responderModeFromURL) {
        console.log('üó∫Ô∏è Responder mode detected, initializing map...');
        require([
            "esri/config",
            "esri/WebMap",
            "esri/views/MapView",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/geometry/Point",
            "esri/widgets/LayerList"
        ], function(esriConfig, WebMap, MapView, GraphicsLayer, Graphic, Point, LayerList) {
            try {
                // Set API key
                esriConfig.apiKey = "AAPTxy8BH1VEsoebNVZXo8HurJNkc1laRp1vAwT3-tXnuF3x-hGfL7b7jMe3CM0GiMyuTTg-lrFRdjvrAWsq9NCjJTcBWf_1bK0AoEE-eukjSiR7_41IaU8ZbnZytMHzhJvd87ZnvexVuj65yOBoclKr2N3ciauOPysAhdUze5Xm2KImfnxpA2Tnh9ANk5OTLlVMowDfQQ6RT5TIcg7um6QJUQi8VHORtLw0-sg5yUsCrVb1Hnp4zkT4zV-ZxpYG0_HAAT1_teoS1mtm";
                
                console.log('üó∫Ô∏è Starting map initialization for responder...');
            
            // Make these available globally for the user update functions
            window.Graphic = Graphic;
            window.Point = Point;

            const map = new WebMap({
                portalItem: {
                    id: "0d8708f95c71433daa14f4ad6965ff2d",
                },
            });
            
            console.log('üó∫Ô∏è WebMap created, loading...');

            const graphicsLayer = new GraphicsLayer();
            map.add(graphicsLayer);
            window.graphicsLayer = graphicsLayer; // Make available globally
            let userGraphic = null;

                // Create responder graphic that will be updated by the main tracking function
            window.userGraphic = null; // Make available globally


            console.log('üó∫Ô∏è Creating MapView...');
            
            // Check if viewDiv exists
            const viewDiv = document.getElementById('viewDiv');
            if (!viewDiv) {
                console.error('üó∫Ô∏è viewDiv container not found!');
                return;
            }
            console.log('üó∫Ô∏è viewDiv container found:', viewDiv);
            
            const view = new MapView({
                container: "viewDiv",
                map: map,
                extent: {
                    xmin: -118.23849978435393,
                    ymin: 34.13414868681906,
                    xmax: -118.00438397317032,
                    ymax: 34.25355759833813,
                    spatialReference: 4326,
                }
            });
            
            view.when(() => {
                console.log('üó∫Ô∏è MapView loaded successfully!');
            }).catch((error) => {
                console.error('üó∫Ô∏è MapView failed to load:', error);
            });

            const layerList = new LayerList({
                view: view
            });

            let isLayerListVisible = true;

            const filterBtn = document.getElementById('filter-layers-btn');

            filterBtn.addEventListener('click', function () {
                if (isLayerListVisible)
                    view.ui.remove(layerList);
                else
                    view.ui.add(layerList, {
                        position: "top-right"
                    });

                isLayerListVisible = !isLayerListVisible;
            });

            let currentLocation;

            if ("geolocation" in navigator) {
                navigator.geolocation.getCurrentPosition(
                    function (position) {
                        const latitude = position.coords.latitude;
                        const longitude = position.coords.longitude;

                        console.log(latitude, longitude);
                        currentLocation = { x: longitude, y: latitude };
                    }
                );
            }

            // Note: Routing functionality requires additional imports (RouteLayer, Stop)
            // For now, focusing on the basic map display with user locations
            
            console.log('üó∫Ô∏è Responder map initialized successfully');
            
            } catch (error) {
                console.error('üó∫Ô∏è Error initializing responder map:', error);
            }
        }); // Close require function
    } // Close responderModeFromURL check
</script>

</html>
